@using Churchee.Common.Abstractions.Auth
@using Churchee.Common.Abstractions.Queue
@using Churchee.Common.Abstractions.Utilities
@using Churchee.Common.Storage
@using Churchee.Common.ValueTypes
@using Microsoft.AspNetCore.Components.Forms
@using System.Globalization
@using Microsoft.AspNetCore.Components.Web
@using Microsoft.Extensions.Configuration
@using Microsoft.JSInterop
@using Radzen
@using Radzen.Blazor
@using System.ComponentModel.DataAnnotations


<RadzenUpload Change="HandleFileUpload" Auto="false" Multiple="false"  />

@if (uploadProgress > 0 && uploadProgress < 100)
{
    <RadzenProgressBar ProgressBarStyle="ProgressBarStyle.Primary" Value="uploadProgress" ShowValue="false" />
}
@if (uploadProgress == 100)
{
    <RadzenProgressBar ProgressBarStyle="ProgressBarStyle.Success" Value="100" ShowValue="false" />
}


<small>@status</small>

<RadzenFormField Text="Description" AllowFloatingLabel="false">

    <ChildContent>

    <div style="display: flex; align-items: center;">
            <RadzenTextBox Style="width: 100%" @oninput="OnDescriptionInput" Value="@Model.Description" />
            <RadzenProgressBarCircular Visible="generating" Mode="ProgressBarMode.Indeterminate" Size="ProgressBarCircularSize.ExtraSmall" Style="margin-right: 1rem">
                <Template>AI</Template> 
            </RadzenProgressBarCircular>
    </div>

    </ChildContent>
    <Helper>
        <ValidationMessage For="() => Model.Description" />
    </Helper>

</RadzenFormField>

@code {

    [Inject]
    private ICurrentUser CurrentUser { get; set; } = default!;

    [Inject]
    private IAiToolUtilities AiToolUtilities { get; set; } = default!;

    [Parameter]
    public ChunkedImageUploadType Model { get; set; } = default!;

    [Parameter]
    public EventCallback<ChunkedImageUploadType> ModelChanged { get; set; }

    [Parameter]
    public int MaxUploadSize { get; set; } = 5;

    private double uploadProgress = 0;

    private string status = string.Empty;

    private bool generating = false;

    private CancellationTokenSource? _descriptionCts;

    private async Task HandleFileUpload(UploadChangeEventArgs e)
    {
        var file = e.Files.FirstOrDefault() as IBrowserFile;

        if(file == null)
        {
            uploadProgress = 0;

            status = string.Empty;

            StateHasChanged();

            return;
        }

        Model.File = file;

        var applicationTenantId = await CurrentUser.GetApplicationTenantId();

        Model.TempFilePath = await UploadTempFileInChunksAsync(file, CancellationToken.None);

        status = $"Uploaded {file.Name}";

        generating = true;

        StateHasChanged();

        // Cancel any previous alt text generation
        _descriptionCts?.Cancel();
        _descriptionCts = new CancellationTokenSource();

        try
        {
            // Get a read stream for the uploaded file
            await using (var tempFileStream = System.IO.File.Create(Model.TempFilePath))
            {
                await file.OpenReadStream(MaxUploadSize * 1024 * 1024).CopyToAsync(tempFileStream);

                Model.Description = await AiToolUtilities.GenerateAltTextAsync(tempFileStream, _descriptionCts.Token);

            }
        }
        catch (OperationCanceledException)
        {
            // Alt text generation was cancelled by user input
        }
        finally
        {
            generating = false;
            await ModelChanged.InvokeAsync(Model);
            StateHasChanged();

        }
    }

    private void OnDescriptionInput(ChangeEventArgs e)
    {
        Model.Description = e.Value?.ToString() ?? string.Empty;
        _descriptionCts?.Cancel();
        // Optionally, you can set 'generating = false' and call StateHasChanged() if you want to hide the spinner immediately
        generating = false;
        StateHasChanged();
        ModelChanged.InvokeAsync(Model);
    }

    private async Task<string> UploadTempFileInChunksAsync(IBrowserFile file, CancellationToken cancellationToken = default)
    {
        var tempFilePath = System.IO.Path.GetTempFileName();

        string tempFilePathWithRealExt = tempFilePath.Replace(".tmp", Path.GetExtension(file.Name));

        await using (var tempFileStream = System.IO.File.Create(tempFilePathWithRealExt))
        {
            // Read the browser file in chunks and write to temp file
            var buffer = new byte[81920]; // 80KB buffer
            await using var inputStream = file.OpenReadStream(MaxUploadSize * 1024 * 1024);
            int bytesRead;
            double totalRead = 0;
            var totalLength = file.Size;
            do
            {
                bytesRead = await inputStream.ReadAsync(buffer, 0, buffer.Length);
                if (bytesRead > 0)
                {
                    await tempFileStream.WriteAsync(buffer, 0, bytesRead, cancellationToken);
                    totalRead += bytesRead;
                    uploadProgress = totalLength > 0 ? (totalRead / totalLength) * 100 : 0;
                    await InvokeAsync(StateHasChanged);
                }
            } while (bytesRead > 0);
        }

        return tempFilePathWithRealExt;
    }

}